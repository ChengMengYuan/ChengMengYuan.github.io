<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集成微信支付]]></title>
    <url>%2F2018%2F06%2F04%2F%E9%9B%86%E6%88%90%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[在APP中使用微信支付 前言相对比支付宝支付,微信支付显得更LOW一些,集成的时候一大堆烦心事,这里总结一下怎么让APP集成微信支付 注册微信帐号 微信开放平台微信商户平台 提交资料按照步骤提交微信所需要的所有资料ps:非常非常多,审核也很慢,要有耐心(如果可以的话丢给行政或者运营去做,别说是我说的) 开发总算是到了激动人心的开发时刻了(其实到了这一步已经被微信折磨的半死了,能开发确实有点激动人心…) 导入SDK首先第一步,还是导入微信支付的SDK在build.gradle(app)中添加1234dependencies&#123; //微信支付 implementation 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'&#125; 创建文件夹在包名下一级目录里面，新建一个文件夹名字为wxapi。例如程序包名为：com.cmy那么最后结果就该是com.cmy.wxapi 开发 微信官方文档 我把支付相关的逻辑封装了一下,具体代码入下。注释很详细,就不多说了。 使用方法如下 12345678910WXPayUtil.WXPayBuilder builder = new WXPayUtil.WXPayBuilder(); builder.setAppId("")//应用ID .setPartnerId("")//商户号 .setPrepayId("")//预支付交易会话ID .setPackageValue("")//扩展字段 .setNonceStr("")//随机字符串 .setTimeStamp("")//时间戳 .setSign("")//签名 .build() .toWXPayNotSign(this, ""); 微信支付工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255/** * 文 件 名: WXPayUtil&lt;p&gt; * 创 建 人: cmy&lt;p&gt; * 创建日期: 2018/6/4 11:12&lt;p&gt; * 邮 箱: mengyuan.cheng.mier@gmail.com&lt;p&gt; * 文件说明:微信支付工具类,采用了Builder设计模式, * 有后端签名和移动端签名两种调用方式 * 后端签名：由后端保存微信提供的KEY的值,比较安全,推荐使用 * 移动端签名：需要多保存一个微信提供的KEY,非常不安全,如果没有特殊情况请不要使用&lt;p&gt; */public class WXPayUtil &#123; private IWXAPI iwxapi; //微信支付的api private WXPayBuilder builder; private WXPayUtil(WXPayBuilder builder) &#123; this.builder = builder; &#125; public static class WXPayBuilder &#123; /** * 应用ID */ public String appId; /** * 商户号 */ public String partnerId; /** * 预支付交易会话ID */ public String prepayId; /** * 扩展字段 */ public String packageValue; /** * 随机字符串 */ public String nonceStr; /** * 时间戳 */ public String timeStamp; /** * 签名 */ public String sign; public WXPayUtil build() &#123; return new WXPayUtil(this); &#125; public String getAppId() &#123; return appId; &#125; public WXPayBuilder setAppId(String appId) &#123; this.appId = appId; return this; &#125; public String getPartnerId() &#123; return partnerId; &#125; public WXPayBuilder setPartnerId(String partnerId) &#123; this.partnerId = partnerId; return this; &#125; public String getPrepayId() &#123; return prepayId; &#125; public WXPayBuilder setPrepayId(String prepayId) &#123; this.prepayId = prepayId; return this; &#125; public String getPackageValue() &#123; return packageValue; &#125; public WXPayBuilder setPackageValue(String packageValue) &#123; this.packageValue = packageValue; return this; &#125; public String getNonceStr() &#123; return nonceStr; &#125; public WXPayBuilder setNonceStr(String nonceStr) &#123; this.nonceStr = nonceStr; return this; &#125; public String getTimeStamp() &#123; return timeStamp; &#125; public WXPayBuilder setTimeStamp(String timeStamp) &#123; this.timeStamp = timeStamp; return this; &#125; public String getSign() &#123; return sign; &#125; public WXPayBuilder setSign(String sign) &#123; this.sign = sign; return this; &#125; &#125; /** * 调起微信支付的方法,由服务端完成签名。安全,推荐。 * * @param context 上下文 * @param appid appid */ public void toWXPayNotSign(Context context, String appid) &#123; iwxapi = WXAPIFactory.createWXAPI(context, null); //初始化微信api iwxapi.registerApp(appid); //注册appid appid可以在开发平台获取 Runnable payRunnable = new Runnable() &#123; //这里注意要放在子线程 @Override public void run() &#123; PayReq request = new PayReq(); //调起微信APP的对象 //下面是设置必要的参数，也就是前面说的参数,这几个参数从何而来请看上面说明 request.appId = builder.getAppId(); request.partnerId = builder.getPartnerId(); request.prepayId = builder.getPrepayId(); request.packageValue = "Sign=WXPay";// request.packageValue = builder.getPackageValue(); request.nonceStr = builder.getNonceStr(); request.timeStamp = builder.getTimeStamp(); request.sign = builder.getSign(); Log.e("chx", "run: " + request.appId + request.nonceStr + request.sign); iwxapi.sendReq(request);//发送调起微信的请求 &#125; &#125;; Thread payThread = new Thread(payRunnable); payThread.start(); &#125; /** * 调起微信支付的方法,由移动端完成签名。不安全,不推荐。 * * @param context 上下文 * @param appid appid * @param key 微信提供的key */ public void toWXPayAndSign(Context context, String appid, final String key) &#123; iwxapi = WXAPIFactory.createWXAPI(context, null); //初始化微信api iwxapi.registerApp(appid); //注册appid appid可以在开发平台获取 Runnable payRunnable = new Runnable() &#123; //这里注意要放在子线程 @Override public void run() &#123; if (TextUtils.isEmpty(builder.getAppId()) || TextUtils.isEmpty(builder.getPartnerId()) || TextUtils.isEmpty(builder.getPrepayId())) &#123; Log.e("chx", "toWXPayAndSign: " + "必须在builder中设置appId、PartnerId、PrepayId"); return; &#125; PayReq request = new PayReq(); //调起微信APP的对象 //下面是设置必要的参数，也就是前面说的参数,这几个参数从何而来请看上面说明 request.appId = builder.getAppId(); request.partnerId = builder.getPartnerId(); request.prepayId = builder.getPrepayId(); request.packageValue = "Sign=WXPay"; request.nonceStr = genNonceStr(); request.timeStamp = String.valueOf(genTimeStamp()); request.sign = builder.getSign(); //签名 LinkedHashMap&lt;String, String&gt; signParams = new LinkedHashMap&lt;&gt;(); signParams.put("appid", request.appId); signParams.put("noncestr", request.nonceStr); signParams.put("package", request.packageValue); signParams.put("partnerid", request.partnerId); signParams.put("prepayid", request.prepayId); signParams.put("timestamp", request.timeStamp); request.sign = genPackageSign(signParams, key); iwxapi.sendReq(request);//发送调起微信的请求 &#125; &#125;; Thread payThread = new Thread(payRunnable); payThread.start(); &#125; /** * 调起微信APP支付，签名 * 生成签名 */ private String genPackageSign(LinkedHashMap&lt;String, String&gt; params, String key) &#123; StringBuilder sb = new StringBuilder(); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; sb.append(entry.getKey()); sb.append('='); sb.append(entry.getValue()); sb.append('&amp;'); &#125; sb.append("key="); sb.append(key); String packageSign = getMessageDigest(sb.toString().getBytes()).toUpperCase(); return packageSign; &#125; /** * md5加密 * * @param buffer * @return 加密后的string */ private String getMessageDigest(byte[] buffer) &#123; char hexDigits[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; MessageDigest mdTemp = MessageDigest.getInstance("MD5"); mdTemp.update(buffer); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return null; &#125; &#125; /** * 获取随机数 * * @return */ private String genNonceStr() &#123; Random random = new Random(); return getMessageDigest(String.valueOf(random.nextInt(10000)).getBytes()); &#125; /** * 获取时间戳 * * @return */ private long genTimeStamp() &#123; return System.currentTimeMillis() / 1000; &#125;&#125; 支付结果回调在com.cmy.wxapi包下新建一个java类,取名为 “WXPayEntryActivity”,并且实现IWXAPIEventHandler接口该类的名字一定是在wxapi包下，名字也一定是WXPayEntryActivity。因为他是微信回调的接口，如果改变位置或名字，就会导致微信无法将支付结果反馈，从而导致支付失败。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 文 件 名: WXPayEntryActivity&lt;p&gt; * 创 建 人: cmy&lt;p&gt; * 创建日期: 2018/6/4 11:03&lt;p&gt; * 邮 箱: mengyuan.cheng.mier@gmail.com&lt;p&gt; * 文件说明:位置支付回调类&lt;p&gt; */@SuppressLint("Registered")public class WXPayEntryActivity extends AppCompatActivity implements IWXAPIEventHandler &#123; private IWXAPI api; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // FIXME: 2018/6/4 修改为微信支付的布局页面 setContentView(R.layout.activity_order_detail); api = WXAPIFactory.createWXAPI(this, "appid");//这里填入自己的微信APPID api.handleIntent(getIntent(), this); &#125; @Override public void onReq(BaseReq baseReq) &#123; &#125; @Override public void onResp(BaseResp baseResp) &#123; Log.d("WXPayEntryActivity", "onPayFinish, errCode = " + baseResp.errCode); if (baseResp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123; int errCord = baseResp.errCode; if (errCord == 0) &#123; Log.d("WXPayEntryActivity", "支付成功！"); &#125; else &#123; Log.d("WXPayEntryActivity", "支付失败！"); &#125; /* 这里接收到了返回的状态码可以进行相应的操作， 如果不想在这个页面操作可以把状态码存在本地然后finish掉这个页面， 这样就回到了你调起支付的那个页面 获取到你刚刚存到本地的状态码进行相应的操作就可以了 */ finish(); &#125; &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); api.handleIntent(intent, this); &#125;&#125; 运行结果 微信测试接口地址]]></content>
      <tags>
        <tag>调用</tag>
        <tag>第三方</tag>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android唤起手机地图(高德地图,百度地图,腾讯地图，腾讯地图网页)]]></title>
    <url>%2F2018%2F05%2F29%2FAndroid%E5%94%A4%E8%B5%B7%E6%89%8B%E6%9C%BA%E5%9C%B0%E5%9B%BE-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE-%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%EF%BC%8C%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[调用第三方地图软件 前言最近开发过程中,有个需求是需要调用手机内已经安装的地图软件进行导航,目前国内用户比较多的地图一共也只有三家,分别是 （1）高德地图（2）百度地图（3）腾讯地图 该如何调用这些APP呢?如果用户一个APP都没装又该怎么做呢? 判断是否安装了地图软件12345678910/** * 校验是否装了该应用 * * @param packageName 应用包名 * @return boolean 如果安装了则返回true */ private boolean isPackageInstalled(String packageName) &#123; return new File(Environment.getExternalStorageDirectory().getPath() + packageName) .exists(); &#125; 自动打开地图按照高德&gt;腾讯&gt;百度&gt;网页版的顺序分别尝试打开地图PS:百度的大部分软件我个人都不喜欢,所以将百度地图尽量放在最后调用。 12345678910111213141516171819202122232425262728293031/** * 启动导航 * * @param lat 纬度 * @param lng 经度 */ private void startToNavigation(String lat, String lng) &#123; String gaodeMap = "com.autonavi.minimap"; //高德地图包名：com.autonavi.minimap String tencentMap = "com.tencent.map"; //腾讯地图包名：com.tencent.map String BaiduMap = "com.baidu.BaiduMap"; //百度地图包名：com.baidu.BaiduMap if (isPackageInstalled(gaodeMap)) &#123; materialDialog.dismiss(); startGaodeMap(lat, lng); Log.d("isPackageInstalled", "安装了高德地图APP: "); &#125; else if (isPackageInstalled(tencentMap)) &#123; materialDialog.dismiss(); startTencentMap(lat, lng); //如果安装了腾讯地图APP Log.d("isPackageInstalled", "安装了腾讯地图APP: "); &#125; else if (isPackageInstalled(BaiduMap)) &#123; materialDialog.dismiss(); startBaiduMap(lat, lng); //如果安装了百度地图APP Log.d("isPackageInstalled", "安装了百度地图APP:"); &#125; else &#123; materialDialog.dismiss(); startHTMLMap(lat, lng); //如果什么地图都没安装,则打开网页版地图进行导航 Log.d("isPackageInstalled", "什么地图都没安装: "); &#125; &#125; 打开高德地图123456789101112131415161718192021222324252627282930/** * 打开高德地图进行导航 * * @param lat 目的地经纬度 * @param lng 目的地经纬度 */ private void startGaodeMap(String lat, String lng) &#123; //如果安装了高德地图APP Log.d("isPackageInstalled", "安装了高德地图APP: "); // 高德地图 try &#123; Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); //将功能Scheme以URI的方式传入data Uri uri = Uri.parse("androidamap://navi?sourceApplication=appname" + "&amp;poiname=fangheng" + "&amp;lat=" + lat + "&amp;lon=" + lng + "&amp;dev=1&amp;style=2"); intent.setData(uri); //启动该页面即可 context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); startHTMLMap(lat, lng); &#125; &#125; 打开腾讯地图123456789101112131415161718192021222324/** * 打开腾讯地图进行导航 * * @param lat 目的地经纬度 * @param lng 目的地经纬度 */private void startTencentMap(String lat, String lng) &#123; //如果安装了腾讯地图APP Log.d("isPackageInstalled", "安装了腾讯地图APP: "); // 腾讯地图 try &#123; Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); //将功能Scheme以URI的方式传入data Uri uri = Uri.parse("qqmap://map/routeplan?type=drive&amp;tocoord=" + lat + "," + lng + "&amp;policy=0&amp;referer=baluche"); intent.setData(uri); //启动该页面即可 context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); startHTMLMap(lat, lng); &#125;&#125; 打开百度地图12345678910111213141516171819202122232425262728/** * 打开百度地图进行导航 * * @param lat 目的地经纬度 * @param lng 目的地经纬度 */private void startBaiduMap(String lat, String lng) &#123; //如果安装了百度地图APP Log.d("isPackageInstalled", "安装了百度地图APP: "); // 百度地图 try &#123; Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); //将功能Scheme以URI的方式传入data Uri uri = Uri.parse("baidumap://map/direction?destination=" + lat + "," + lng + "&amp;mode=driving"); intent.setData(uri); //启动该页面即可 context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); startHTMLMap(lat, lng); &#125;&#125; 打开网页地图1234567891011121314151617181920212223242526272829/** * 打开腾讯地图进行导航 * * @param lat 目的地经纬度 * @param lng 目的地经纬度 */ private void startTencentMap(String lat, String lng) &#123; //如果安装了腾讯地图APP Log.d("isPackageInstalled", "安装了腾讯地图APP: "); // 腾讯地图 try &#123; Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); //将功能Scheme以URI的方式传入data Uri uri = Uri.parse("qqmap://map/routeplan?type=drive&amp;tocoord=" + lat + "," + lng + "&amp;policy=0" + "&amp;referer=baluche"); intent.setData(uri); //启动该页面即可 context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); startHTMLMap(lat, lng); &#125; &#125; 运行结果]]></content>
      <tags>
        <tag>地图</tag>
        <tag>调用</tag>
        <tag>第三方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android6.0运行时权限管理]]></title>
    <url>%2F2018%2F05%2F26%2FAndroid6-0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android6.0动态权限最简单的解决方法 前言动态权限管理是Android6.0（B&gt;uild.VERSION_CODES.M =Api23）推出的，提醒用户当前APP所需&gt;要的权限，防止滥用。这些权限一般分为三种： （1）普通权限：直接manifest清单文件中写上注册就行了（2）危险权限：需要动态申请（3）特殊权限：一般用不上。 原声的动态权限管理很麻烦，代码也不够优雅，因此就有很多的动态权限管理库，比较出名一点的有： EasyPermissions RuntimePermission RxPermissions 相较于其他的权限管理库，RxPermissions的代码最为简洁，逻辑也更加清晰。 引入RxPermissions Github地址 关键代码12345678910111213141516171819202122232425262728293031RxPermissions rxPermissions = new RxPermissions(this); rxPermissions .requestEach(Manifest.permission.READ_PHONE_STATE,//读取电话 Manifest.permission.ACCESS_COARSE_LOCATION)//获取位置信息 .subscribe(permission -&gt; &#123; if (permission.granted) &#123; Log.d("rxPermissions", permission.name + "同意了"); switch (permission.name) &#123; case Manifest.permission.READ_PHONE_STATE: break; case Manifest.permission.ACCESS_COARSE_LOCATION: break; &#125; &#125; else if (permission.shouldShowRequestPermissionRationale) &#123; Log.d("rxPermissions", permission.name + "拒绝了"); switch (permission.name) &#123; case Manifest.permission.READ_PHONE_STATE: break; case Manifest.permission.ACCESS_COARSE_LOCATION: break; &#125; &#125; else &#123; switch (permission.name) &#123; case Manifest.permission.READ_PHONE_STATE: break; case Manifest.permission.ACCESS_COARSE_LOCATION: break; &#125; Log.d("rxPermissions", permission.name + "拒绝并不再提示了"); &#125; &#125;); 运行结果]]></content>
      <tags>
        <tag>权限管理</tag>
        <tag>Android6.0</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F05%2F25%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[历经千辛万苦终于搭建好了我自己的博客网站，作为一个爱折腾的技术宅来说内心的满足感简直爆棚。希望接下来能把自己工作中的心得感悟都记录下来，方便以后查看。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>测试</tag>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
</search>
